import numpy as np
import math
from itertools import combinations
import time
import mph
import os

#model units:
#time: ms
#length: microns
#mass: 1e-15 kg 

def simulation(r_thrombus,cylinder_rad,time_simulation,ext_act,input_porosity,design_file,output_file,dir,dir2):
    #main fuction that performs dynamic simulation and hydrodynamics computation
    #input parameters
    #r_thrombus- thrombus radius (microns)
    #cylinder_rad- vessel radius (microns)
    #time_simulation- time of dynamic simulation (ms)
    #ext_act- extent of platelet activation. determines critical interplatelet force via formula :critical interplatelet force= 2.5 nN*ext_act*ext_act
    #input_porosity- input thrombus porosity, it will be approximately equal to real porosity of thrombus after relaxation (at least if input_porosity is in tested range 0.53-0.7)
    #design_file- path to design_file, basic Comsol file with .mph extension which is used to solve hydrodynamic equation in vessel with thrombus
    #output_file- path to output_file, Comsol file with .mph extension, generated by programm, which contains solved hydrodynamics in vessel with thrombus
    #dir- path to directory where to store secodary output data files with .txt extension
    #dir2- path to directory where to store main output data file with .txt extension
    #technical parameters
    #dt-time step (ms)
    dt=2e-4*(0.35/ext_act)
    #n_steps- number of steps in simulation
    n_steps=round(time_simulation/dt)
    # start timer
    time_start=time.time()
    #start initiation module
    #get initial platelet positions and velocities and estimated thrombus volume
    #pos- array of platelet positions
    #pos_last- array of platelet positions at the previous time step
    #rad- array of platelet radii
    #ext_activation- array of platelet extent of activation
    #V_thrombus- estimated thrombus volume
    pos,pos_last,rad,ext_activation,V_thrombus=initiate_thrombus(r_thrombus,cylinder_rad,ext_act,input_porosity)
    #get average platelet radius after generation
    r_average=get_average_rad(rad)
    #get initial data
    str_initial=log_initial_data(r_thrombus,cylinder_rad,V_thrombus,r_average,time_simulation,ext_act)
    #set values of paramenters used in neighbouring pair-based algorithm which speeds up the computation of inter-platelet forces
    #maximal displacement of platelet compared to initial state (when pos_back array was generated)
    current_move=0
    #pairs_dict- array of pairs of interacting platelets
    pairs_dict=[]
    #use_neighbours-boolean, which defines whether to use this pairs_dict array in computation of interplatelet forces or not
    use_neighbours=False
    #pos_back- platelet positions at moment of computing pairs_dict
    pos_back=[]
    #start platelet dynamics module
    #start and continue relaxation process for given number of steps
    for i in range(n_steps):
        if i%10000==0:
            print(i*dt)
        #make solution about using pairs_dict in computation of forces
        if i>0:
            use_neighbours,current_move,pairs_dict,pos_back=pair_based_algorithm(pos,pos_back,rad,use_neighbours,current_move,pairs_dict)
        #get forces between platelets 
        # calculate interplatelet integrin forces via Morse potential and elastic repulsion
        f_interplatelet=interaction_between_platelets_numpy(pos,rad,ext_act,ext_activation,pairs_dict,use_neighbours)
        # calculate forces between platelets and wall
        f_wall=interaction_with_wall(pos,rad,cylinder_rad)
        # get numpy arrays
        f_interplatelet=np.asarray(f_interplatelet)
        f_wall=np.asarray(f_wall)
        # get total Newton forces acting on platelets
        f_total=f_interplatelet+f_wall
        #get new platelet positions using Verlet method
        pos,pos_last=verlet_scheme(pos,pos_last,rad,f_total,dt)
    #start hydrodynamics module
    #perform correction of radii for pairs of intersecting platelets
    pos_mesh,rad_mesh,str_mesh=intersection_correction(pos,rad)
    #perform correction of radii for near wall platelets
    pos_mesh2,rad_mesh2,str_wall_mesh=intersection_wall_correction(pos_mesh,rad_mesh,cylinder_rad)
    #calculate hydrodynamics in comsol and get output data
    #hydro_forces- array of hydrodynamic forces acting on platelets
    #str_comsol_output-output comsol computation data
    hydro_forces,str_comsol_output=comsol_hydrodynamics_computation2(design_file,output_file,pos_mesh2,rad_mesh2,cylinder_rad,r_thrombus,dir)
    #gather and process output data
    #get number of interacting pairs of platelets
    limit_distance=0.5
    pairs_dict=get_pairs_dict(pos_mesh2,rad_mesh2,limit_distance)
    number_of_interacting_pairs=len(pairs_dict)
    #dump initial and output data
    time_comp=time.time()-time_start
    #initial data
    str_initial=str_initial+'\nnumber of platelets='+str(len(pos))
    #output data
    str_output_data='\nnumber of interacting pairs of platelets='+str(number_of_interacting_pairs)
    #time of computation data
    str_time='\ntime of computation='+str(time_comp)+' s'+'\ntime of computation/n_platelets='+str(time_comp/len(rad))+' s/plt'
    #full data
    str_log='input data\n'+'\n'+str_initial+'\n'+'\noutput data'+str_output_data+'\n'+'\ncorrections to get proper mesh\n'+str_mesh+'\n'+'\ncorrections near wall to get proper mesh\n'+str_wall_mesh+str_comsol_output+str_time
    #write output data file with .txt extension, which contatins all the important information about the simulation results
    log_data(str_log,r_thrombus,dir2)

def initiate_thrombus(r_thrombus,cylinder_rad,ext_act,input_porosity):
    #function generates initial platelet positions
    #parameters
    #estimate thrombus volume
    V_thrombus=estimate_thrombus_volume(r_thrombus,cylinder_rad)
    #get target porosity
    critical_porosity=input_porosity-0.02
    #create arrays
    #positions of platelets
    pos=[]
    #positions of platelets at last time step
    pos_last=[]
    #extent of paltelet activation
    ext_activation=[]
    #platelet radii
    rad=[]
    #use numpy to generate random numbers
    rng = np.random.default_rng()
    #boolean variable stop controls the cycle
    stop=False
    #current volume of generated platelets in thrombus
    current_volume=0
    while not stop:
        #generate platelet position and radius
        # position
        hx=2*(rng.random()-0.5)*r_thrombus
        hy=-rng.random()*r_thrombus+cylinder_rad
        hz=2*(rng.random()-0.5)*r_thrombus
        #radius
        hr=1+0.22*rng.normal(0,1,1)[0]
        flag=True
        #apply cutoff (2.72 sigma)
        if hr<0.4:
            flag=False
        # make sure that platelet is inside thrombus domain
        if math.pow(hx,2)+math.pow(hy-cylinder_rad,2)+math.pow(hz,2)>math.pow(r_thrombus,2):
            flag=False
        if math.pow(math.pow(hx,2)+math.pow(hy,2),0.5)+hr>cylinder_rad:
            flag=False
        # if platelet satisfy above consitions- add it to alredy generated platelets
        if flag:
            pos.append([hx,hy,hz])
            pos_last.append([hx,hy,hz])
            rad.append(hr)
            ext_activation.append(ext_act)
            current_volume=current_volume+(4/3)*math.pi*pow(hr,3)
            current_porosity=1-current_volume/V_thrombus
            # if target porosity is reached- stop the process
            if current_porosity<critical_porosity:
                stop=True
    return pos,pos_last,rad,ext_activation,V_thrombus


def get_average_rad(rad):
    #function compute average radius of platelet based on mean platelet surface area
    s=0
    for i in range(len(rad)):
        s=s+rad[i]*rad[i]
    s_average=s/len(rad)
    r_average=math.sqrt(s_average)
    #rescale microns to m
    r_average=r_average*1e-6
    return r_average

def log_initial_data(r_thrombus,cylinder_rad,V_thrombus,r_average,time_simulation,ext_act):
    #log initital_data
    str_initial='thrombus volume='+str(V_thrombus)+' micron^3'+'\ninput thrombus radius='+str(r_thrombus)+' micron'+'\naverage platelet radius='+str(r_average)+' m'+'\ncylinder radius='+str(cylinder_rad)+' micron'+'\ntime_simulation='+str(time_simulation)+' ms'+'\next_act='+str(ext_act)    
    return str_initial


def pair_based_algorithm(pos,pos_back,rad,use_neighbours,current_move,pairs_dict):
    #function is implementation of neighbouring pair-based algorithm, which is used to speed up computation of inter-platelet forces 
    limit_distance=1
    #use_neighbours- boolean variable whcih controls whether to use pairs_dict to compute interplatelet forces, or not
    if use_neighbours==False:
        #print('we')
        use_neighbours=True
        current_move=0
        #get array of pairs of interacting platelets
        pairs_dict=get_pairs_dict(pos,rad,limit_distance)
        # get current positions of platelets
        pos_back=[[0,0,0]for i in range(len(pos))]
        for i in range(len(pos)):
            for k in range(3):
                pos_back[i][k]=pos_back[i][k]+pos[i][k]
    else:
        # calculate maximal platelet displacement using pos_back array 
        current_move,index_max_move=get_current_move(pos,pos_back)
        current_move=current_move*2
        if current_move>limit_distance-0.5-0.01:
            # if displacement exceeds critical value- clear arrays and parameters
            use_neighbours=False
            pairs_dict=[]
            pos_back=[]
            current_move=0 
    return use_neighbours,current_move,pairs_dict,pos_back

def interaction_between_platelets(pos,rad,ext_activation):
    # computation of interplatelet forces in python. slow, so it is not used    
    #model parameters
    # constant defining amplitude of Morse potential
    k_morse=1e7
    # parameter defining width of morse potential curve
    alpha=10
    # constant defining amplitude of platelet-platelet repulsion
    k_repulsion=45e5
    #create arrray of forces acting on platelets
    forces =[[0,0,0] for i in range(len(pos))]
    for i in range(len(pos)):
        for j in range(i):
            #calculate distance between centers of platetels
            distance=0
            for k in range(3):    
                distance=distance+(pos[i][k]-pos[j][k])*(pos[i][k]-pos[j][k])
            distance=np.sqrt(distance)
            #calculate magnitude of interplatelet forces
            if distance-rad[i]-rad[j]<0.5:
                #we use small correction factor 0.02 to reduce number of intersecting platelets
                if (distance-rad[i]-rad[j]>0.02):
                    tmp_exp=np.exp(-alpha*(distance-rad[i]-rad[j]))        
                    f=k_morse*ext_activation[i]*ext_activation[j]*tmp_exp*(1-tmp_exp)  
                else:
                    f=k_repulsion*(distance-rad[i]-rad[j]-0.02)
                #calculate projections of interplatelet forces 
                f_proj=[]
                for k in range(3):
                    f_proj.append(f*(pos[j][k]-pos[i][k])/distance)
                for k in range(3):
                    forces[i][k]=forces[i][k]+f_proj[k]
                    forces[j][k]=forces[j][k]-f_proj[k]
    return forces  

def interaction_between_platelets_numpy(pos,rad,ext_act,ext_activation,pairs_dict,use_neighbours):
    # computation of interplatelet forces in numpy, using neighbouring pair-based algorithm to speed up calculations
    #model parameters
    # constant defining amplitude of Morse potential
    k_morse=1e7
    # parameter defining width of morse potential curve
    alpha=10
    # constant defining amplitude of platelet-platelet repulsion
    k_repulsion=45e5*(ext_act*ext_act)/(0.35*0.35)
    #create arrray of forces acting on platelets
    forces =[[0,0,0] for i in range(len(pos))]
    forces=np.asarray(forces,dtype=np.float64)
    # to get array of possibly interacting pairs of plateltes(pairs_array), we can use or not use pairs_dict array
    #if we can not use pairs_dict array, we generate array of all possible pairs of platelets (called pairs_array)
    if not use_neighbours:
        index_array=np.arange(len(pos))
        pairs_array=list(combinations(index_array,2))
    #else we use pairs_dict as pairs_array
    else:
        pairs_array=pairs_dict
    pairs_array=np.asarray(pairs_array)
    #create array of distances between centers of platelets
    distance_array=[] 
    #create array of  distances between surfaces of platelets
    close_array=[]
    #additioanl arrays as tools 
    dd_array=[]
    rr_array=[]
    pos=np.asarray(pos,dtype=np.float64)
    rad=np.asarray(rad,dtype=np.float64)
    #compute arrays of distances between centers and surfaces based on pairs_array
    #get indexes of plateletes in pairs
    st1=pairs_array[:,0]
    st2=pairs_array[:,1]
    # get positions of platelets in pairs
    st3=pos[st1]
    st4=pos[st2]
    #get vectors from center of first platelet to center of second platelet in pairs
    dist_arr1=st3-st4
    #get sum of radii of plateelts in pairs
    rr_array=rad[st1]+rad[st2]
    #get array of distances between centers of platelets
    distance_array=np.sum(dist_arr1*dist_arr1,1) 
    distance_array=np.sqrt(distance_array) 
    #get array of distances between surfaces of platelets
    close_array=distance_array-rr_array
    #apply cutoff 0.5 micron ( in our model platelets do not interact if interplatett distance>0.5 microns)
    v=[0.5 for i in range (len(close_array))]
    v=np.asarray(v)
    bool_mask=np.less(close_array,v)
    #get arrays of distances between ceneters surfaces of interacting platelets
    sorted_close_array=close_array[bool_mask]
    sorted_distance_array=distance_array[bool_mask]
    # get array of interacting pairs of platetls
    sorted_pairs_array=pairs_array[bool_mask]
    #Morse attraction forces arrays
    v2=[0.02 for i in range (len(sorted_close_array))]
    v2=np.asarray(v2)
    bool_mask_attr=np.greater(sorted_close_array,v2)
    sorted_close_array_attr=sorted_close_array[bool_mask_attr]
    sorted_distance_array_attr=sorted_distance_array[bool_mask_attr]
    sorted_pairs_array_attr=sorted_pairs_array[bool_mask_attr]
    #elastic repulsion forces arrays
    bool_mask_rep=np.less_equal(sorted_close_array,v2)
    sorted_close_array_rep=sorted_close_array[bool_mask_rep]
    sorted_distance_array_rep=sorted_distance_array[bool_mask_rep]
    sorted_pairs_array_rep=sorted_pairs_array[bool_mask_rep]
    v3=v2[bool_mask_rep]
    #Morse attraction forces computation(magnitude)
    tmp1=-alpha*sorted_close_array_attr
    tmp_exp=np.exp(tmp1)
    tmp2=k_morse*tmp_exp*(1-tmp_exp)
    #ext_act_array
    ext_act_array=[]
    for s in range (len(sorted_close_array_attr)):
        ext_act_array.append(ext_activation[sorted_pairs_array_attr[s][0]]*ext_activation[sorted_pairs_array_attr[s][1]])
    ext_act_array=np.asarray(ext_act_array)
    force_attraction=tmp2*ext_act_array
    force_attr_my=[]
    for i in range(len(force_attraction)):
        force_attr_my.append([force_attraction[i]])
    force_attr_my=np.asarray(force_attr_my)
    #elastic repulsion forces computation (magnitude)
    force_repulsion=k_repulsion*(sorted_close_array_rep-v3)
    #force_repulsion=k_repulsion*(sorted_close_array_rep)
    force_rep_my=[]
    for i in range(len(force_repulsion)):
        force_rep_my.append([force_repulsion[i]])
    force_rep_my=np.asarray(force_rep_my)
    #projections on x, y, z axes
    vec_attr=[]
    for s in range (len(sorted_close_array_attr)): 
        vec=[]
        for k in range(3):
            vec.append((pos[sorted_pairs_array_attr[s][1]][k]-pos[sorted_pairs_array_attr[s][0]][k])/sorted_distance_array_attr[s])
        vec_attr.append(vec)
    vec_rep=[]
    for s in range (len(sorted_close_array_rep)): 
        vec=[]
        for k in range(3):
            vec.append((pos[sorted_pairs_array_rep[s][1]][k]-pos[sorted_pairs_array_rep[s][0]][k])/sorted_distance_array_rep[s])
        vec_rep.append(vec)
    vec_attr=np.asarray(vec_attr)
    vec_rep=np.asarray(vec_rep)
    force_attr_vec=force_attr_my*vec_attr
    force_rep_vec=force_rep_my*vec_rep
    #computation of projections of force acting on each platelet
    for i in range(len(sorted_pairs_array_attr)):
        forces[sorted_pairs_array_attr[i][0]]=forces[sorted_pairs_array_attr[i][0]]+force_attr_vec[i]
        forces[sorted_pairs_array_attr[i][1]]=forces[sorted_pairs_array_attr[i][1]]-force_attr_vec[i]
    for i in range(len(sorted_pairs_array_rep)):
        forces[sorted_pairs_array_rep[i][0]]=forces[sorted_pairs_array_rep[i][0]]+force_rep_vec[i]
        forces[sorted_pairs_array_rep[i][1]]=forces[sorted_pairs_array_rep[i][1]]-force_rep_vec[i]
    return forces 

def interaction_with_wall(pos,rad,cylinder_rad):
    # computation of forces between platelets and vessel wall
    # vessel cylinder wall
    # constant defining amplitude of repulsion
    k_wall=5e6
    # constant defining amplitude of attraction
    k_wall2=5e6
    #create arrray of forces acting on platelets
    forces =[[0,0,0] for i in range(len(pos))]
    for i in range (len(pos)):
        #calculate distance between platelet center and vessel wall
        wall_dist=cylinder_rad-math.pow(math.pow(pos[i][0],2)+math.pow(pos[i][1],2),0.5)
        #calculate magnitude of repulsion (if platelet intersect or almost intersect with wall)
        if wall_dist-0.01< rad[i]:
           f=k_wall*(rad[i]+0.01-wall_dist)
        #calculate magnitude of attraction( works only for platelets attached to vessel wall, mimicks interaction with collagen/endotelial cell etc.)
        elif wall_dist<2*rad[i]: 
            f=k_wall2*(rad[i]+0.01-wall_dist)
        else:
            f=0
        #calculate projections of forces, acting on each platelet
        for k in range(2):   
            if not f==0:     
                forces[i][k]=forces[i][k]-f*pos[i][k]/math.pow(math.pow(pos[i][0],2)+math.pow(pos[i][1],2),0.5)
    return forces

def verlet_scheme(pos,pos_last,rad,f_total,dt):
    #calculate dynamics of platelets using Verlet method
    # parameters
    #basic platelet radius
    rad_0=1
    #effective viscosity coefficient
    vis=3141*6
    #basic platelet mass
    mass=4
    #create 2 arrays of platelet positions
    pos1 =[[0,0,0] for i in range(len(pos))]
    pos2 =[[0,0,0] for i in range(len(pos))]  
    for i in range(len(pos)):
        for k in range(3):
            #calculate platelet mass 
            mass_ref=rad[i]*rad[i]*rad[i]/(rad_0*rad_0*rad_0)
            #calculate factors for computation
            factor1=1/(1+dt*vis/(2*mass*mass_ref))
            factor2=(1-dt*vis/(2*mass*mass_ref)) 
            #calculate new platelet position
            pos1[i][k]=factor1*(2*pos[i][k]-factor2*pos_last[i][k]+f_total[i][k]*dt*dt/(mass*mass_ref)) 
            #calculate position on the previous time step
            pos2[i][k]=pos[i][k] 
    for i in range(len(pos)):
        for k in range(3): 
            pos[i][k]=pos1[i][k]
            pos_last[i][k]=pos2[i][k]  
    return pos,pos_last  


def get_current_move(pos,pos_back):
    #calculate maximal platelet displacement using platelet positions at 'initial' and current moments
    #create numpy arrays
    pos_np=np.asarray(pos,dtype=np.float64)
    pos_back_np=np.asarray(pos_back,dtype=np.float64)
    #vectors of platelet displacements
    dif=pos_np-pos_back_np
    dif2=dif*dif
    dif3=np.sum(dif2,1)
    #values of platelet displacements
    dif4=np.sqrt(dif3)
    #maximal displacement
    current_move=np.max(dif4)  
    #index of platelet
    index_max_move=np.argmax(dif4)
    return current_move,index_max_move

def intersection_correction(pos,rad):
    #correction of radii of intersecting platelets (nessecary to generate mesh in vessel with thrombus)
    #parameters
    #number of corrected pairs of platelets
    n_pairs=0
    #critical value to get mesh quality 0.01 (in comsol)
    key_delta=0.01
    #
    #rad=[0 for i in range(len(rad_in))]
    #pos=[[0,0,0] for i in range(len(pos_in))]
    #for i in range(len(pos_in)):
    #    for k in range(3):
    #        pos[i][k]=pos[i][k]+pos_in[i][k]
    #for i in range(len(rad_in)):
    #    rad[i]=rad[i]+rad_in[i]
    #total volume of platelets in thrombus before correction of radii
    vol1=0
    for i in range(len(rad)):
        vol1=vol1+(4/3)*np.pi*math.pow(rad[i],3)
    for i in range(len(pos)):
        for j in range(i):
            #calculate distance between platelet centers
            distance=0
            for k in range(3):    
                distance=distance+(pos[i][k]-pos[j][k])*(pos[i][k]-pos[j][k])
            distance=np.sqrt(distance)
            #calculate distance between platelet borders
            close=distance -rad[i]-rad[j]
            #if distance is less than critical value- change radii of platelets
            if close<key_delta: 
                n_pairs=n_pairs+1              
                rad[i]=rad[i]-(key_delta-close)/2
                rad[j]=rad[j]-(key_delta-close)/2
                if rad[i]<=0:
                    rad[i]=0.001                
                if rad[j]<=0:
                    rad[j]=0.001              
    #total volume of platelets in thrombus after correction of radii
    vol2=0
    for i in range(len(rad)):
        vol2=vol2+(4/3)*np.pi*math.pow(rad[i],3)
    #output data about changes
    str1='number of corrected pairs of platelets='+str(n_pairs)+'\n'+'initial volume='+str(vol1)+' micron^3'+'\ndelta volume='+str(vol1-vol2)+' micron^3'+'\ndelta percent='+str(100*(1-vol2/vol1))+' %'
    return pos,rad,str1

def intersection_wall_correction(pos,rad,cylinder_rad):
    #correction of radii of platelets intersecting with wall (nessecary to generate mesh in vessel with thrombus)
    #parameters
    #number of corrected platelets    
    n_plts=0
    # to get mesh quality 0.01 (in comsol)
    key_delta=0.01
    #
    #rad=[0 for i in range(len(rad_in))]
    #pos=[[0,0,0] for i in range(len(pos_in))]
    #for i in range(len(pos_in)):
    #    for k in range(3):
    #        pos[i][k]=pos[i][k]+pos_in[i][k]
    #for i in range(len(rad_in)):
    #    rad[i]=rad[i]+rad_in[i]
    #total volume of platelets in thrombus before correction of radii
    vol1=0
    for i in range(len(rad)):
        vol1=vol1+(4/3)*np.pi*math.pow(rad[i],3)
    for i in range (len(pos)):
        #calculate distance between platelet center and vessel wall
        wall_dist=cylinder_rad-math.pow(math.pow(pos[i][0],2)+math.pow(pos[i][1],2),0.5)
        #if distance is less than critical value- change radius of platelet
        if wall_dist< rad[i]+key_delta:
           q_dist=rad[i]+key_delta-wall_dist
           rad[i]=rad[i]-q_dist
           n_plts=n_plts+1
           if rad[i]<=0:
               rad[i]=0.001  
    #total volume of platelets in thrombus after correction of radii            
    vol2=0
    for i in range(len(rad)):
        vol2=vol2+(4/3)*np.pi*math.pow(rad[i],3)
    #output data about changes
    str1='number of corrected platelets='+str(n_plts)+'\n'+'initial volume='+str(vol1)+' micron^3'+'\ndelta volume='+str(vol1-vol2)+' micron^3'+'\ndelta percent='+str(100*(1-vol2/vol1))+' %'
    return pos,rad,str1



def comsol_hydrodynamics_computation(design_file,output_file,pos_mesh,rad_mesh,cylinder_rad,r_thrombus,dir):
    #function imports data about geometry of thrombus and vessel in comsol, builds mesh, solves hydrodynamic equations, and get output data
    #start timer
    time_start3=time.time()
    #get vessel cylinder geometry
    cylinder_length=round(170.58*cylinder_rad)
    #start client
    client = mph.start(cores=2)
    #load design_file- basic file, which is used as template to build geometry in comsol
    model= client.load(design_file)
    #clear geometry
    model.java.component("comp1").geom("geom1").feature().clear()
    model.java.component("comp1").geom("geom1").selection().clear()
    #create vessel cylinder
    model.java.component("comp1").geom("geom1").create("c3", "Cylinder")
    #set geometric parameters of vessel cylinder
    model.java.component("comp1").geom("geom1").feature("c3").set("r", str(cylinder_rad))    
    model.java.component("comp1").geom("geom1").feature("c3").set("h", str(cylinder_length))
    model.java.component("comp1").geom("geom1").feature("c3").set("x", "0")
    model.java.component("comp1").geom("geom1").feature("c3").set("y", "0")
    model.java.component("comp1").geom("geom1").feature("c3").set("z", str(-cylinder_length/2))
    model.java.component("comp1").geom("geom1").feature("c3").set("axis", "0 0 1")
    model.java.component('comp1').geom('geom1').selection().create("csel1", "CumulativeSelection")
    #generate platelets
    for i in range(len(pos_mesh)):
        x_pl=pos_mesh[i][0]
        y_pl=pos_mesh[i][1]
        z_pl=pos_mesh[i][2]
        rad_pl=rad_mesh[i]
        model.java.component('comp1').geom('geom1').create("sph"+str(i), "Sphere")
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("r", str(rad_pl))
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("x", str(x_pl))     
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("y", str(y_pl))
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("z", str(z_pl))
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("selresult", 'on')
        model.java.component("comp1").geom("geom1").feature("sph"+str(i)).set("selresultshow", "bnd")
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("contributeto", "csel1")
    #create difference domain between vessel and platelets
    model.java.component('comp1').geom('geom1').create("dif1", "Difference")
    model.java.component('comp1').geom('geom1').feature("dif1").selection("input").set("c3")
    model.java.component('comp1').geom('geom1').feature("dif1").selection("input2").named("csel1")
    model.java.component('comp1').geom('geom1').run()
    #set boundary conditions
    model.java.component("comp1").physics("spf").create("inl1", "InletBoundary", 2)
    model.java.component("comp1").physics("spf").feature("inl1").selection().set(4)
    model.java.component("comp1").physics("spf").feature("inl1").set("BoundaryCondition", "Pressure")
    model.java.component("comp1").physics("spf").feature("inl1").set("p0", '350')
    model.java.component("comp1").physics("spf").create("out1", "OutletBoundary", 2)
    model.java.component("comp1").physics("spf").feature("out1").selection().set(3)
    #set fine mesh
    model.java.component("comp1").mesh("mesh1").feature("size").set("hauto", '4')
    model.java.component("comp1").mesh("mesh1").feature("size1").set("hauto", '2')
    #model.java.component('comp1').geom('geom1').run()
    #build mesh
    model.mesh()
    #solve
    model.solve()
    #output data
    #get array of hydrodynamic forces acting on thrombus in table 2
    #create table, set expressions
    model.java.result().table().create("tbl1", "Table")
    model.java.result().numerical().create("int1", "IntSurface")
    model.java.result().numerical("int1").set("intvolume", 'on')
    model.java.result().numerical("int1").setIndex("expr", "p*nx-spf.K_stress_tensorxy*ny-spf.K_stress_tensorxx*nx-spf.K_stress_tensorxz*nz", 0)
    model.java.result().numerical().create("int2", "IntSurface")
    model.java.result().numerical("int2").set("intvolume", 'on')
    model.java.result().numerical("int2").setIndex("expr", "p*ny-spf.K_stress_tensoryy*ny-spf.K_stress_tensoryx*nx-spf.K_stress_tensoryz*nz", 0)
    model.java.result().numerical().create("int3", "IntSurface")
    model.java.result().numerical("int3").set("intvolume", 'on')
    model.java.result().numerical("int3").setIndex("expr", "p*nz-spf.K_stress_tensorzy*ny-spf.K_stress_tensorzx*nx-spf.K_stress_tensorzz*nz", 0)
    #get results for the first platelet    
    i=0  
    model.java.result().numerical("int1").selection().named('geom1_sph'+str(i)+'_bnd')
    model.java.result().numerical("int1").set("table", "tbl1")
    model.java.result().numerical("int1").setResult()
    model.java.result().numerical("int2").selection().named('geom1_sph'+str(i)+'_bnd')
    model.java.result().numerical("int2").set("table", "tbl1")
    model.java.result().numerical("int2").appendResult()
    model.java.result().numerical("int3").selection().named('geom1_sph'+str(i)+'_bnd')
    model.java.result().numerical("int3").set("table", "tbl1")
    model.java.result().numerical("int3").appendResult()
    #get results for the rest.
    for i in range(1,len(pos_mesh)):
        model.java.result().numerical("int1").selection().named('geom1_sph'+str(i)+'_bnd')
        model.java.result().numerical("int1").set("table", "tbl1")
        model.java.result().numerical("int1").appendResult()
        model.java.result().numerical("int2").selection().named('geom1_sph'+str(i)+'_bnd')
        model.java.result().numerical("int2").set("table", "tbl1")
        model.java.result().numerical("int2").appendResult()
        model.java.result().numerical("int3").selection().named('geom1_sph'+str(i)+'_bnd')
        model.java.result().numerical("int3").set("table", "tbl1")
        model.java.result().numerical("int3").appendResult()
    #process data about forces acting on platelets
    data_file='data_'+str(r_thrombus)+'.txt'
    model.java.result().table("tbl1").save(data_file)
    file_name=dir+'/'+data_file
    hydrodynamic_forces=read_data_file(file_name)
    hydrodynamic_forces=np.asarray(hydrodynamic_forces)
    #rescale N to model unit fN
    hydrodynamic_forces=1e15*hydrodynamic_forces
    # calculate 3 force projections for each platelet
    hydro_force=[]
    for i in range(len(pos_mesh)):
        hydro_force.append([hydrodynamic_forces[3*i],hydrodynamic_forces[3*i+1],hydrodynamic_forces[3*i+2]])
    #get additional data about forces and velocities in thrombus
    #get data about bulk force acting on thrombus
    model.java.result().numerical().create("int4", "IntSurface")
    model.java.result().numerical("int4").set("intvolume", 'on')
    model.java.result().numerical("int4").selection().named("geom1_csel1_bnd")
    model.java.result().numerical("int4").setIndex("expr", "p*nz-spf.K_stress_tensorzy*ny-spf.K_stress_tensorzx*nx-spf.K_stress_tensorzz*nz", 0)
    model.java.result().table().create("tbl2", "Table")
    model.java.result().table("tbl2").comments("addational data about thrombus: z-projection bulk hydrodynamic force,velocities")
    model.java.result().numerical("int4").set("table", "tbl2")
    model.java.result().numerical("int4").setResult()
    #get data about velocities in thrombus
    #start with average z-velocity in internal zone
    rad_real,rad_wall=get_effective_thrombus_radius(pos_mesh,rad_mesh,cylinder_rad)
    rad_internal=rad_real-4
    if rad_internal<1:
        rad_internal=1
    rad_internal_square=rad_internal*rad_internal
    model.java.result().numerical().create("int5", "IntVolume")
    model.java.result().numerical("int5").selection().all()
    model.java.result().numerical("int5").setIndex("expr", 'w*step1('+str(rad_internal_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 0)
    model.java.result().numerical("int5").setIndex("expr", 'step1('+str(rad_internal_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 1)
    model.java.result().numerical("int5").set("table", "tbl2")
    model.java.result().numerical("int5").appendResult()
    #average z-velocity in deep zone
    rad_deep=rad_real/2
    if rad_deep<1:
        rad_deep=1
    rad_deep_square=rad_deep*rad_deep
    model.java.result().numerical().create("int6", "IntVolume")
    model.java.result().numerical("int6").selection().all()
    model.java.result().numerical("int6").setIndex("expr", 'w*step1('+str(rad_deep_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 0)
    model.java.result().numerical("int6").setIndex("expr", 'step1('+str(rad_deep_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 1)
    model.java.result().numerical("int6").set("table", "tbl2")
    model.java.result().numerical("int6").appendResult()
    #average surface 2 layers velocity
    rad_real_square=rad_real*rad_real
    model.java.result().numerical().create("int7", "IntVolume")
    model.java.result().numerical("int7").selection().all()
    model.java.result().numerical("int7").setIndex("expr",'spf.U*step1('+str(rad_real_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))*step1(-'+str(rad_internal_square)+'+1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)+1e6*x[m]*1e6*x[m]+(1e6*z[m])*(1e6*z[m]))' , 0)
    model.java.result().numerical("int7").setIndex("expr",'step1('+str(rad_real_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))*step1(-'+str(rad_internal_square)+'+1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)+1e6*x[m]*1e6*x[m]+(1e6*z[m])*(1e6*z[m]))' , 1)
    model.java.result().numerical("int7").set("table", "tbl2")
    model.java.result().numerical("int7").appendResult()
    #inlet flow
    model.java.result().numerical().create("int8", "IntSurface")
    model.java.result().numerical("int8").set("intvolume", 'on')
    model.java.result().numerical("int8").selection().set(4)
    model.java.result().numerical("int8").setIndex("expr", "w", 0)
    model.java.result().numerical("int8").set("table", "tbl2")
    model.java.result().numerical("int8").appendResult()
    #average platelet radius esimate based on bulk platelet surface area
    model.java.result().numerical().create("int9", "IntSurface")
    model.java.result().numerical("int9").set("intvolume", 'on')
    model.java.result().numerical("int9").selection().named("geom1_csel1_bnd")
    model.java.result().numerical("int9").setIndex("expr", '1', 0)
    model.java.result().numerical("int9").set("table", "tbl2")
    model.java.result().numerical("int9").appendResult()
    #process addational data
    number_of_platelets=len(pos_mesh)
    data_file2='force_and_velocitites_data_'+str(r_thrombus)+'.txt'
    model.java.result().table("tbl2").save(data_file2)
    file_name2=dir+'/'+data_file2
    add_data=read_data_file(file_name2)
    str_comsol_output=gather_additional_data(number_of_platelets,rad_real,rad_wall,rad_internal,rad_deep,cylinder_rad,add_data)
    model.save(output_file)
    time_comsol=(time.time()-time_start3)
    str_comsol_output=str_comsol_output+'\ntime of computation in comsol='+str(time_comsol)+' s'
    return hydro_force,str_comsol_output

def comsol_hydrodynamics_computation2(design_file,output_file,pos_mesh,rad_mesh,cylinder_rad,r_thrombus,dir):
    #function imports data about geometry of thrombus and vessel in comsol, builds mesh, solves hydrodynamic equations, and get output data
    #model considers 2 fluids: whole blood in vessel, blood plasma in thrombus
    #start timer
    time_start3=time.time()
    #get vessel cylinder geometry
    cylinder_length=round(170.58*cylinder_rad)
    #start client
    client = mph.start(cores=2)
    #load design_file- basic file, which is used as template to build geometry in comsol
    model= client.load(design_file)
    #clear geometry
    model.java.component("comp1").geom("geom1").feature().clear()
    model.java.component("comp1").geom("geom1").selection().clear()
    #create vessel cylinder
    model.java.component("comp1").geom("geom1").create("c3", "Cylinder")
    model.java.component("comp1").geom("geom1").feature("c3").set("r", str(cylinder_rad))    
    model.java.component("comp1").geom("geom1").feature("c3").set("h", str(cylinder_length))
    model.java.component("comp1").geom("geom1").feature("c3").set("x", "0")
    model.java.component("comp1").geom("geom1").feature("c3").set("y", "0")
    model.java.component("comp1").geom("geom1").feature("c3").set("z", str(-cylinder_length/2))
    model.java.component("comp1").geom("geom1").feature("c3").set("axis", "0 0 1")
    model.java.component('comp1').geom('geom1').selection().create("csel1", "CumulativeSelection")
    #generate platelets
    for i in range(len(pos_mesh)):
        x_pl=pos_mesh[i][0]
        y_pl=pos_mesh[i][1]
        z_pl=pos_mesh[i][2]
        rad_pl=rad_mesh[i]
        model.java.component('comp1').geom('geom1').create("sph"+str(i), "Sphere")
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("r", str(rad_pl))
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("x", str(x_pl))     
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("y", str(y_pl))
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("z", str(z_pl))
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("selresult", 'on')
        model.java.component("comp1").geom("geom1").feature("sph"+str(i)).set("selresultshow", "bnd")
        model.java.component('comp1').geom('geom1').feature("sph"+str(i)).set("contributeto", "csel1")
    #create difference between vessel and platelets
    model.java.component('comp1').geom('geom1').create("dif1", "Difference")
    model.java.component('comp1').geom('geom1').feature("dif1").selection("input").set("c3")
    model.java.component('comp1').geom('geom1').feature("dif1").selection("input2").named("csel1")
    #get model with thrombus domain and vessel domain with 2 different fluids (blood plasma and whole blood)
    #get thrombus domain radius
    rad_real_0,rad_wall_0=get_effective_thrombus_radius(pos_mesh,rad_mesh,cylinder_rad)
    domain_rad=rad_real_0+2
    #generate auxilary ball domain
    model.java.component("comp1").geom("geom1").create("sph"+str(len(pos_mesh)), "Sphere")
    model.java.component("comp1").geom("geom1").feature("sph"+str(len(pos_mesh))).set("r", str(domain_rad))
    model.java.component('comp1').geom('geom1').feature("sph"+str(len(pos_mesh))).set("x", str(0))     
    model.java.component('comp1').geom('geom1').feature("sph"+str(len(pos_mesh))).set("y", str(cylinder_rad))
    model.java.component('comp1').geom('geom1').feature("sph"+str(len(pos_mesh))).set("z", str(0))
    #use partition operation
    model.java.component("comp1").geom("geom1").create("par1", "Partition");
    model.java.component("comp1").geom("geom1").feature("par1").selection("input").set("dif1")
    model.java.component("comp1").geom("geom1").feature("par1").selection("tool").set("sph"+str(len(pos_mesh)))
    model.java.component("comp1").geom("geom1").run("par1")
    model.java.component("comp1").geom("geom1").run()
    #ball selection
    #1 (get thrombus domain)
    model.java.component("comp1").geom("geom1").create("ballsel1", "BallSelection")
    model.java.component("comp1").geom("geom1").feature("ballsel1").set("posx", str(0))
    model.java.component("comp1").geom("geom1").feature("ballsel1").set("posy", str(cylinder_rad))
    model.java.component("comp1").geom("geom1").feature("ballsel1").set("posz", str(0))
    model.java.component("comp1").geom("geom1").feature("ballsel1").set("r", str(domain_rad+1))
    model.java.component("comp1").geom("geom1").feature("ballsel1").set("condition", "inside")
    model.java.component('comp1').geom('geom1').run()
    #set physics
    #full domain
    model.java.component("comp1").physics("spf").selection().all()
    #set boundary with box selection
    #inlet
    model.java.component("comp1").physics("spf").create("inl1", "InletBoundary", 2)
    model.java.component("comp1").geom("geom1").create("boxsel1", "BoxSelection")
    model.java.component("comp1").geom("geom1").feature("boxsel1").set("entitydim", '2')
    model.java.component("comp1").geom("geom1").feature("boxsel1").set("zmin", str(cylinder_length/2-0.05))
    model.java.component("comp1").geom("geom1").feature("boxsel1").set("zmax",str(cylinder_length/2+0.05) )
    model.java.component("comp1").geom("geom1").run("boxsel1")
    model.java.component("comp1").geom("geom1").feature("boxsel1").set("condition", "inside")
    model.java.component("comp1").geom("geom1").selection().create("csel2", "CumulativeSelection")
    model.java.component("comp1").geom("geom1").selection("csel2").label("Cumulative Selection 2")
    model.java.component("comp1").geom("geom1").feature("boxsel1").set("contributeto", "csel2")
    model.java.component("comp1").geom("geom1").run()
    model.java.component("comp1").physics("spf").feature("inl1").selection().named("geom1_boxsel1")
    model.java.component("comp1").physics("spf").feature("inl1").set("BoundaryCondition", "Pressure")
    #outlet
    model.java.component("comp1").physics("spf").create("out1", "OutletBoundary", 2)
    model.java.component("comp1").geom("geom1").create("boxsel2", "BoxSelection")
    model.java.component("comp1").geom("geom1").feature("boxsel2").set("entitydim", '2')
    model.java.component("comp1").geom("geom1").feature("boxsel2").set("zmin", str(-cylinder_length/2-0.05))
    model.java.component("comp1").geom("geom1").feature("boxsel2").set("zmax",str(-cylinder_length/2+0.05) )
    model.java.component("comp1").geom("geom1").run("boxsel2")
    model.java.component("comp1").geom("geom1").feature("boxsel2").set("condition", "inside")
    model.java.component("comp1").geom("geom1").selection().create("csel3", "CumulativeSelection")
    model.java.component("comp1").geom("geom1").selection("csel3").label("Cumulative Selection 3")
    model.java.component("comp1").geom("geom1").feature("boxsel2").set("contributeto", "csel3")
    model.java.component("comp1").geom("geom1").run()
    model.java.component("comp1").physics("spf").feature("out1").selection().named("geom1_boxsel2")
    model.java.component("comp1").physics("spf").feature("out1").set("BoundaryCondition", "Pressure")
    #set pressure(to get wall shear rate 1000 1/s in thrombus-free vessel)
    model.java.component("comp1").physics("spf").feature("inl1").set("p0", '1170')
    model.java.component("comp1").physics("spf").feature("out1").set("p0", '0')
    #set viscosity in domains
    model.java.component("comp1").physics("spf").feature("fp1").set("mu_mat", "userdef")
    model.java.component("comp1").physics("spf").feature("fp1").set("mu", '0.0034')
    #set density in domains
    #whole blood density: Shmukler, Michael (2004). Elert, Glenn (ed.). "Density of blood". The Physics Factbook.
    model.java.component("comp1").physics("spf").feature("fp1").set("rho_mat", "userdef")
    model.java.component("comp1").physics("spf").feature("fp1").set("rho", '1060')
    #set thrombus domain
    model.java.component("comp1").physics("spf").create("fp2", "FluidProperties", 3)
    model.java.component("comp1").physics("spf").feature("fp2").selection().named("geom1_ballsel1")
    #set viscosity in thrombus 
    #blood plasma viscosity: doi.org/10.3389/fphys.2019.01329
    model.java.component("comp1").physics("spf").feature("fp2").set("mu_mat", "userdef")
    model.java.component("comp1").physics("spf").feature("fp2").set("mu", '0.00125')
    #set density in thrombus
    #blood plasma density: Shmukler, Michael (2004). Elert, Glenn (ed.). "Density of blood". The Physics Factbook.
    model.java.component("comp1").physics("spf").feature("fp2").set("rho_mat", "userdef")
    model.java.component("comp1").physics("spf").feature("fp2").set("rho", '1025')
    #set mesh
    model.java.component("comp1").mesh("mesh1").feature("size").set("hauto", '4')
    model.java.component("comp1").mesh("mesh1").feature("size1").set("hauto", '2')
    model.java.component('comp1').geom('geom1').run()
    #build mesh
    model.mesh()
    #solve model
    model.solve()
    #save file
    model.save(output_file)
    #get array of hydrodynamic forces acting on thrombus in table 2
    #create table, write expressions
    model.java.result().table().create("tbl1", "Table")
    model.java.result().numerical().create("int1", "IntSurface")
    model.java.result().numerical("int1").set("intvolume", 'on')
    model.java.result().numerical("int1").setIndex("expr", "p*nx-spf.K_stress_tensorxy*ny-spf.K_stress_tensorxx*nx-spf.K_stress_tensorxz*nz", 0)
    model.java.result().numerical().create("int2", "IntSurface")
    model.java.result().numerical("int2").set("intvolume", 'on')
    model.java.result().numerical("int2").setIndex("expr", "p*ny-spf.K_stress_tensoryy*ny-spf.K_stress_tensoryx*nx-spf.K_stress_tensoryz*nz", 0)
    model.java.result().numerical().create("int3", "IntSurface")
    model.java.result().numerical("int3").set("intvolume", 'on')
    model.java.result().numerical("int3").setIndex("expr", "p*nz-spf.K_stress_tensorzy*ny-spf.K_stress_tensorzx*nx-spf.K_stress_tensorzz*nz", 0)
    #get results for the first platelet    
    i=0  
    model.java.result().numerical("int1").selection().named('geom1_sph'+str(i)+'_bnd')
    model.java.result().numerical("int1").set("table", "tbl1")
    model.java.result().numerical("int1").setResult()
    model.java.result().numerical("int2").selection().named('geom1_sph'+str(i)+'_bnd')
    model.java.result().numerical("int2").set("table", "tbl1")
    model.java.result().numerical("int2").appendResult()
    model.java.result().numerical("int3").selection().named('geom1_sph'+str(i)+'_bnd')
    model.java.result().numerical("int3").set("table", "tbl1")
    model.java.result().numerical("int3").appendResult()
    #get results for the rest.
    for i in range(1,len(pos_mesh)):
        model.java.result().numerical("int1").selection().named('geom1_sph'+str(i)+'_bnd')
        model.java.result().numerical("int1").set("table", "tbl1")
        model.java.result().numerical("int1").appendResult()
        model.java.result().numerical("int2").selection().named('geom1_sph'+str(i)+'_bnd')
        model.java.result().numerical("int2").set("table", "tbl1")
        model.java.result().numerical("int2").appendResult()
        model.java.result().numerical("int3").selection().named('geom1_sph'+str(i)+'_bnd')
        model.java.result().numerical("int3").set("table", "tbl1")
        model.java.result().numerical("int3").appendResult()
    #process data about forces acting on platelets
    data_file='data_'+str(r_thrombus)+'.txt'
    model.java.result().table("tbl1").save(data_file)
    file_name=dir+'/'+data_file
    hydrodynamic_forces=read_data_file(file_name)
    hydrodynamic_forces=np.asarray(hydrodynamic_forces)
    #rescale N to model unit fN
    hydrodynamic_forces=1e15*hydrodynamic_forces
    #get 3 force projections for each platelet
    hydro_force=[]
    for i in range(len(pos_mesh)):
        hydro_force.append([hydrodynamic_forces[3*i],hydrodynamic_forces[3*i+1],hydrodynamic_forces[3*i+2]])
    #get additional data about forces and velocities in thrombus
    #get data about bulk force acting on thrombus
    model.java.result().numerical().create("int4", "IntSurface")
    model.java.result().numerical("int4").set("intvolume", 'on')
    model.java.result().numerical("int4").selection().named("geom1_csel1_bnd")
    model.java.result().numerical("int4").setIndex("expr", "p*nz-spf.K_stress_tensorzy*ny-spf.K_stress_tensorzx*nx-spf.K_stress_tensorzz*nz", 0)
    model.java.result().table().create("tbl2", "Table")
    model.java.result().table("tbl2").comments("addational data about thrombus: z-projection bulk hydrodynamic force,velocities")
    model.java.result().numerical("int4").set("table", "tbl2")
    model.java.result().numerical("int4").setResult()
    #get data about velocities in thrombus
    #start with average z-velocity in internal zone
    rad_real,rad_wall=get_effective_thrombus_radius(pos_mesh,rad_mesh,cylinder_rad)
    rad_internal=rad_real-4
    if rad_internal<1:
        rad_internal=1
    rad_internal_square=rad_internal*rad_internal
    model.java.result().numerical().create("int5", "IntVolume")
    model.java.result().numerical("int5").selection().all()
    model.java.result().numerical("int5").setIndex("expr", 'w*step1('+str(rad_internal_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 0)
    model.java.result().numerical("int5").setIndex("expr", 'step1('+str(rad_internal_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 1)
    model.java.result().numerical("int5").set("table", "tbl2")
    model.java.result().numerical("int5").appendResult()
    #average z-velocity in deep zone
    rad_deep=rad_real/2
    if rad_deep<1:
        rad_deep=1
    rad_deep_square=rad_deep*rad_deep
    model.java.result().numerical().create("int6", "IntVolume")
    model.java.result().numerical("int6").selection().all()
    model.java.result().numerical("int6").setIndex("expr", 'w*step1('+str(rad_deep_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 0)
    model.java.result().numerical("int6").setIndex("expr", 'step1('+str(rad_deep_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))', 1)
    model.java.result().numerical("int6").set("table", "tbl2")
    model.java.result().numerical("int6").appendResult()
    #average surface 2 layers velocity
    rad_real_square=rad_real*rad_real
    model.java.result().numerical().create("int7", "IntVolume")
    model.java.result().numerical("int7").selection().all()
    model.java.result().numerical("int7").setIndex("expr",'spf.U*step1('+str(rad_real_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))*step1(-'+str(rad_internal_square)+'+1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)+1e6*x[m]*1e6*x[m]+(1e6*z[m])*(1e6*z[m]))' , 0)
    model.java.result().numerical("int7").setIndex("expr",'step1('+str(rad_real_square)+'-1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)-1e6*x[m]*1e6*x[m]-(1e6*z[m])*(1e6*z[m]))*step1(-'+str(rad_internal_square)+'+1e12*(y[m]-'+str(cylinder_rad)+'e-6)*(y[m]-'+str(cylinder_rad)+'e-6)+1e6*x[m]*1e6*x[m]+(1e6*z[m])*(1e6*z[m]))' , 1)
    model.java.result().numerical("int7").set("table", "tbl2")
    model.java.result().numerical("int7").appendResult()
    #inlet flow
    model.java.result().numerical().create("int8", "IntSurface")
    model.java.result().numerical("int8").set("intvolume", 'on')
    model.java.result().numerical("int8").selection().named("geom1_boxsel1")
    model.java.result().numerical("int8").setIndex("expr", "w", 0)
    model.java.result().numerical("int8").set("table", "tbl2")
    model.java.result().numerical("int8").appendResult()
    #average platelet radius esimate based on bulk platelet surface area
    model.java.result().numerical().create("int9", "IntSurface")
    model.java.result().numerical("int9").set("intvolume", 'on')
    model.java.result().numerical("int9").selection().named("geom1_csel1_bnd")
    model.java.result().numerical("int9").setIndex("expr", '1', 0)
    model.java.result().numerical("int9").set("table", "tbl2")
    model.java.result().numerical("int9").appendResult()
    #process addational data
    number_of_platelets=len(pos_mesh)
    data_file2='force_and_velocitites_data_'+str(r_thrombus)+'.txt'
    model.java.result().table("tbl2").save(data_file2)
    file_name2=dir+'/'+data_file2
    add_data=read_data_file(file_name2)
    str_comsol_output=gather_additional_data(number_of_platelets,rad_real,rad_wall,rad_internal,rad_deep,cylinder_rad,add_data)
    model.save(output_file)
    time_comsol=(time.time()-time_start3)
    str_comsol_output=str_comsol_output+'\ntime of computation in comsol='+str(time_comsol)+' s'
    return hydro_force,str_comsol_output

def get_pairs_dict(pos,rad,limit_distance):
    #get array of pairs of platelets with interplatelet distance<limit_distance
    #array  of indexes of platelets
    index_array=np.arange(len(pos))
    #array of pairs of platelets
    pairs_array=list(combinations(index_array,2))
    #create array of distances between platelet centers
    distance_array=[] 
    #create array of distances between platelet borders
    close_array=[]
    #create additional arrays
    dd_array=[]
    rr_array=[]
    pairs_array=np.asarray(pairs_array)
    #create numpy array with platelet positions
    pos=np.asarray(pos,dtype=np.float64)
    #create numpy array with platelet radii
    rad=np.asarray(rad,dtype=np.float64)
    #get arrays of distances between centers and borders of platelets based on pairs array
    st1=pairs_array[:,0]
    st2=pairs_array[:,1]
    st3=pos[st1]
    st4=pos[st2]
    dist_arr1=st3-st4
    rr_array=rad[st1]+rad[st2]
    distance_array=np.sum(dist_arr1*dist_arr1,1) 
    #array of distances between platelet centers
    distance_array=np.sqrt(distance_array) 
    #array of distances between platelet borders
    close_array=distance_array-rr_array
    v=[limit_distance for i in range (len(close_array))]
    v=np.asarray(v,dtype=np.float64)
    bool_mask=np.less(close_array,v)
    #arrays for close pairs (close ditance<limit_distance)
    sorted_pairs_array=pairs_array[bool_mask]
    return sorted_pairs_array


def log_data(str_log,r_thrombus,dir2):
    #write file with data stored in str_log
    name1=dir2+'/r_'+str(r_thrombus)+'_log'+'.txt'
    open(name1,'a').close
    with open(name1, 'w') as f:
        f.write(str_log)


def log_initial_data2(r_thrombus,cylinder_rad,r_average,time_simulation,ext_act):
    #log initial_data
    str_initial='\ninput thrombus radius='+str(r_thrombus)+' micron'+'\naverage platelet radius='+str(r_average)+' m'+'\ncylinder radius='+str(cylinder_rad)+' micron'+'\ntime_simulation='+str(time_simulation)+' ms'+'\next_act='+str(ext_act)    
    return str_initial


def gather_additional_data(number_of_platelets,rad_real,rad_wall,rad_internal,rad_deep,cylinder_rad,add_data):
    #process data stored in add_data variable generated in comsol_hydrodynamics_computation2
    #get bulk force acting on thrombus
    bulk_force=add_data[0]
    #get contact force acting on thrombus
    area_contact=estimate_area_of_contact(rad_wall,cylinder_rad)
    #rescale in m^2
    area_contact2=area_contact*1e-12
    if area_contact>0:
        contact_force=3.1415*bulk_force/area_contact
    else:
        contact_force='no data'
    #get internal velocity inside thrombus
    if add_data[2]>0:
        internal_velocity=add_data[1]/add_data[2]
    else:
        internal_velocity='no data'
    # get deep velocity inside thrombus
    if add_data[4]>0:
        deep_velocity=add_data[3]/add_data[4]
    else:
        deep_velocity='no data'
    #get surface velocity in 2 surface layers of thrombus
    if add_data[6]>0:
        surface_velocity=add_data[5]/add_data[6]
    else:
        surface_velocity='no data'
    # get internal porosity of thrombus
    V_estimated_internal=estimate_thrombus_volume(rad_internal,cylinder_rad)
    #rescale it to m^3
    V_estimated_internal=V_estimated_internal*1e-18
    if V_estimated_internal>0:
        internal_porosity=add_data[2]/V_estimated_internal
    else:
        internal_porosity='no data'
    # get deep porosity inside thrombus
    V_estimated_deep=estimate_thrombus_volume(rad_deep,cylinder_rad)
    #rescale it to m^3
    V_estimated_deep=V_estimated_deep*1e-18
    if V_estimated_deep>0:
        deep_porosity=add_data[4]/V_estimated_deep
    else:
        deep_porosity='no data'
    #inlet flow
    inlet_flow=add_data[7]
    #thrombus platelet surface area
    thrombus_surface_area=add_data[8]
    #avarage platelet radius estimate
    if number_of_platelets>0:
        average_pl_radius=math.sqrt(thrombus_surface_area/(4*math.pi*number_of_platelets))
    else:
        average_pl_radius='no data'
    #surface_to_volume_ratio of thrombus
    V_estimated_full=estimate_thrombus_volume(rad_real,cylinder_rad)
    #rescale volume to m^3
    V_estimated_full=V_estimated_full*1e-18
    if V_estimated_full>0:
        surface_to_volume=thrombus_surface_area/V_estimated_full
    else:
        surface_to_volume='no data'
    #gather output comsol data
    str_comsol_first='\noutput comsol data'+'\n'+'\nreal thrombus radius='+str(rad_real)+' micron'+'\nreal thrombus-vessel contact radius='+str(rad_wall)+' micron'+'\ninternal radius='+str(rad_internal)+' micron'+'\ndeep radius='+str(rad_deep)+' micron'+'\nreal thrombus-vessel contact area='+str(area_contact2)+' m^2'
    str_comsol_second='\nz-projection of bulk hydrodynamic force='+str(bulk_force)+' N'+'\ncontact force='+str(contact_force)+' N'+'\ninternal velocity='+str(internal_velocity)+' m/s'+'\ndeep velocity='+str(deep_velocity)+' m/s'+'\nsurface 2 layers velocity='+str(surface_velocity)+' m/s'+'\ninternal porosity='+str(internal_porosity)+'\ndeep porosity='+str(deep_porosity)+'\ninlet flow='+str(inlet_flow)+' m^3/s'+'\nthrombus surface area='+str(thrombus_surface_area)+' m^2'+'\naverage platelet radius='+str(average_pl_radius)+' m'+'\nthrombus volume='+str(V_estimated_full)+' m^3'+'\nsurface-to-volume ratio='+str(surface_to_volume)+' 1/m'
    str_comsol_output=str_comsol_first+str_comsol_second
    return str_comsol_output

def read_data_file(file_name):
    #read file
    arr_out=[]
    with open (file_name, "r") as file1:
        lines = file1.readlines()
        str=lines[len(lines)-1]
        arr=str.split (sep=' ', maxsplit=-1)
        for i in range(len(arr)):
            if not arr[i]=='':
                arr_out.append(float(arr[i]))
    return arr_out

def get_effective_thrombus_radius(pos,rad,cylinder_rad):
    #get thrombus radius
    #thrombus radius
    rad_real=0
    #radius corresponding to zone of contact between thrombus and vessel
    rad_wall=0
    for i in range(len(pos)):
        hx=pos[i][0]
        hy=pos[i][1]
        hz=pos[i][2]
        square_rad=math.pow(hx,2)+math.pow(hy-cylinder_rad,2)+math.pow(hz,2)
        rad1=math.sqrt(square_rad)
        if rad1>rad_real:
            rad_real=rad1
        wall_dist=cylinder_rad-math.pow(math.pow(pos[i][0],2)+math.pow(pos[i][1],2),0.5)
        if wall_dist<2*rad[i]:
            if rad1>rad_wall:
                rad_wall=rad1
    return rad_real,rad_wall
       
def estimate_area_of_contact(r_thrombus,cylinder_rad):
    #rough estimate of thrombus-vessel contact area 
    #in vessel radius 17 microns it gives errors less then 0.3% for all possible thrombus radii>=5 microns
    #units: micrometer^2
    #parameters
    resolution=200
    step_mesh=r_thrombus/resolution
    resolution2=int(2*math.pi*cylinder_rad/step_mesh)
    #number of mesh points in thrombus
    n_points=0
    #area of mesh zone
    area_mesh=2*math.pi*cylinder_rad*2*r_thrombus
    #total number of points in mesh
    total_n_points=0
    for i in range(resolution2):
        for j in range(-resolution,resolution):
            total_n_points=total_n_points+1
            #generate mesh point
            hx=cylinder_rad*math.sin(2*math.pi*i/resolution2)
            hy=cylinder_rad*math.cos(2*math.pi*i/resolution2)
            hz=step_mesh*j
            flag=True
            #check that point is inside thrombus-vessel area of contact
            if math.pow(hx,2)+math.pow(hy-cylinder_rad,2)+math.pow(hz,2)>math.pow(r_thrombus,2):
                flag=False
            if flag:
                n_points=n_points+1
    #estimate area of vessel-thrombus contact
    area_real=(n_points/total_n_points)*area_mesh
    return area_real

def estimate_thrombus_volume(r_thrombus,cylinder_rad):
    #rough estimate of thrombus volume for initiate_thrombus function
    #units: micrometer^3
    # in vessel radius 17 microns it gives errors less then 0.3% for all possible thrombus radii>=5 microns
    #parameters
    resolution=100
    mesh_step=r_thrombus/resolution
    #volume of mesh_zone
    volume_mesh=8*pow(r_thrombus,3)
    #total number of points in mesh
    total_n_points=8*pow(resolution,3)
    # number of mesh points in thrombus
    n_points=0
    for i in range(-resolution,resolution):
        for j in range(-resolution,resolution):
            for k in range(-resolution,resolution):
                #generate mesh point 
                point=[i*mesh_step,j*mesh_step+cylinder_rad,k*mesh_step]
                hx=point[0]
                hy=point[1]
                hz=point[2] 
                flag=True
                #check that point is inside thrombus
                if math.pow(hx,2)+math.pow(hy-cylinder_rad,2)+math.pow(hz,2)>math.pow(r_thrombus,2):
                    flag=False
                if math.pow(math.pow(hx,2)+math.pow(hy,2),0.5)>cylinder_rad:
                    flag=False
                if flag:
                    n_points=n_points+1
    #estimate thrombus volume
    V_thrombus=(n_points/total_n_points)*volume_mesh
    return V_thrombus        
